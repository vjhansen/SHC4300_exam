### W02-D3 Binary multiplication with a FSMD


*Consider a circuit that receives two 4-bit operands, and generates an 8-bit result that represents the product of the two inputs.*

<img src="/Resources/images/w02d3.png" alt="drawing" width="350"/>



-----

#### 1. Represent a block diagram showing an FSMD architecture for this circuit, assuming that the multiplication is carried out by adding `In_A` with itself, for as many times as indicated by `In_B` (e.g. 12x5 = 12+12+12+12+12).

<img src="/Resources/images/w2d3_1.png" alt="drawing" width="650"/>

*didn't include `clk` or `rst`*

----

#### 2. Represent an ASMD chart for this FSMD.

<img src="/Resources/images/w2d3_2.png" alt="drawing" width="550"/>

----

#### 3. Create a VHDL code for this FMSD.
```vhdl
entity bin_mult is
   port(
      clk, reset : in std_logic;
      in_A, in_B : out std_logic_vector(3 downto 0);
      out_result: out std_logic_vector(7 downto 0));
end bin_mult;

architecture arch of bin_mult is
   type state_type is (state_0, state_1);
   signal state_reg, state_next: state_type;
   signal add_reg, add_next: unsigned(3 downto 0);
   signal out_reg, out_next: std_logic_vector(7 downto 0);
begin
   -- FSMD state & data registers
   process(clk, reset) begin
      if reset='1' then
         state_reg <= state_0;
         add_reg <= (others=>'0');
         out_reg <= (others=>'0');
      elsif rising_edge(clk) then
         state_reg <= state_next;
         add_reg <= add_next;
         out_reg <= out_next;
      end if;
   end process;
   -- next-state logic & data path functional units/routing
   process(state_reg,s_reg,n_reg,b_reg) begin
      state_next <= state_reg;
      s_next <= s_reg;
      n_next <= n_reg;
      b_next <= b_reg;
      rx_done_tick <='0';
      case state_reg is
         when idle =>
            if rx='0' then
               state_next <= start;
               s_next <= (others=>'0');
            end if;
         when start =>
            if (s_tick = '1') then
               if s_reg=7 then
                  state_next <= data;
                  s_next <= (others=>'0');
                  n_next <= (others=>'0');
               else
                  s_next <= s_reg + 1;
               end if;
            end if;
      end case;
   end process;
   dout <= b_reg;
end arch;

```


----

#### 4. Add the necessary blocks to demonstrate the operation of your solution, using the 8 switches to define the two operands, and the 7-segment digits to display the result.


----


#### 5. What changes would be required to your datapath in order to ensure that the multiplication always takes the smallest possible number of clock cycles?
